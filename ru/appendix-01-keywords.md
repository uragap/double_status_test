## Дополнение А: Ключевые слова

Следующий список состоит из ключевых слов, зарезервированных для текущего или будущего использования в Rust. Таким образом, данные слова нельзя использовать для идентификаторов в программах (кроме сырых идентификаторов, которые мы обсудили в разделе "[Сырые идентификаторы]<!--  -->"), включая имена функций, переменных, параметров, имена полей структур, модулей, пакетов, констант, макросов, статических переменных, атрибутов, имён типов, типажей или времён жизни.

### Ключевые слова в Rust

Следующие ключевые слова имеют описанную функциональность.

- `as` - простое приведение типа, устранение неоднозначности реализованного для элемента трейта, или переименование элементов в `use` и `extern crate`
- `async` -  возврат объекта `Future` вместо блокировки выполнения текущего потока
- `await` - приостановка выполнения до тех пор, пока результат выполнения `Future` не станет готов
- `break` - немедленное прекращение цикла
- `const` - объявляет константу или константный сырой указатель
- `continue` - перейти к следующей итерации цикла
- `crate` - подключение внешнего крейта или макро-переменной, представляющей внешний пакет, в котором она объявлена
- `dyn` - динамическая диспетчеризация для трейт-объектов
- `else` - альтернатива для `if` и `if let`
- `enum` - определение перечисления
- `extern` - определение использования внешнего пакета, функции или переменной
- `false` - логический литерал false
- `fn` - определение функции или типа-указателя на функцию
- `for` -  цикл по элементам итератора, реализация трейта или указание времени жизни высокого уровня
- `if` - условный оператор ветвления
- `impl` - наследование или реализация трейта
- `in` - часть синтаксической конструкции цикла `for`
- `let` - определение, привязывание переменной
- `loop` - бесконечный цикл
- `match` - оператор сопоставления значения с образцом
- `mod` - оператор определения модуля
- `move` - позволяет замыканию брать во владение всё, что "захватывает" замыкание
- `mut` - обозначение изменяемых переменных, ссылок, сырых указателей или привязок к шаблону
- `pub` - обозначение публичного доступа к полям структуры, `impl` блокам или модулям
- `ref` - ссылочное связывание
- `return` - оператор возврата из функции
- `Self` - псевдоним типа, для которого объявляется или реализуется типаж
- `self` - предмет метода или текущий модуль
- `static` - глобальная переменная или время жизни, продолжающееся всё время работы программы
- `struct` - определение структуры
- `super` - родительский модуль относительно текущего
- `trait` - обозначение трейта
- `true` - логический литерал true
- `type` - объявление псевдонима типа или ассоциированного типа
- `union` - определение [объединения] что и является единственным ключевым словом при использовании в объединении
- `unsafe` - определение небезопасного кода, функции, трейта или реализаций
- `use` - оператор импорта символов в текущую область видимости
- `where` - оператор условия-ограничения для типа
- `while` - условный цикл, основанный на результате вычисления выражения

### Ключевые слова, зарезервированные для будущего использования

Следующие ключевые слова не имеют функциональности, но они зарезервированы в Rust для возможного использования в будущем.

- `abstract`
- `become`
- `box`
- `do`
- `final`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### Сырые идентификаторы

*Сырые идентификаторы* - это синтаксис, позволяющий вам использовать ключевые слова там, где обычно они не могут быть. Для создания и использования сырого идентификатора, к ключевому слову добавляется префикс `r#`.

Например, ключевое слово `match`. Если вы попытаетесь скомпилировать следующую функцию, использующую в качестве имени `match`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

вы получите ошибку:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

Ошибка говорит о том, что вы не можете использовать ключевое слово `match` в качестве идентификатора функции. Чтобы получить возможность использования слова `match` в качестве имени функции, нужно использовать синтаксис "сырых идентификаторов", например так:

<span class="filename">Файл: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

Этот код скомпилируется без ошибок. Обратите внимание, что префикс `r#` в определении имени функции, указан также, как он указан в месте её вызова в `main`.

Сырые идентификаторы позволяют использовать любые слова <br>в качестве идентификатора, даже если это зарезервированное <br>слово. Дополнительно сырые идентификаторы позволяют использовать библиотеки, написанные на отличной от используемой вами редакции Rust. Например `try`  является ключевым словом в 2018 редакции, но не в 2015. Если вы зависите от библиотеки, написанной с использованием 2015 редакции и имеющей функцию `try`, то для вызова такой функции из код 2018 редакции, вам необходимо использовать синтаксис сырых идентификаторов. В данном случае `r#try`. Детальнее про редакции рассмотрены более детально в [Приложении Е]<!-- . -->


[Сырые идентификаторы]: #raw-identifiers
[объединения]: ../reference/items/unions.html
[Приложении Е]: appendix-05-editions.html
